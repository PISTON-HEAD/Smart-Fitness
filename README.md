Below is **todayâ€™s problem** â€” upgraded to your current level.
This is a **big real-world Spring Boot OOP project**, combining:

âœ” Core OOP
âœ” Spring Boot DI & REST
âœ” JPA inheritance + repository
âœ” Profiles
âœ” Config / Bean / Qualifier
âœ” Streams (filter, sort, map, collect, groupingBy, averaging, max/min)
âœ” Lambdas
âœ” HashMap & Map operations
âœ” Composition + Polymorphism

This is your most advanced problem so far â€” the perfect next step.

---

# ğŸš€ **TODAYâ€™S ADVANCED SPRING + OOP PROBLEM**

## **SmartFitness â€” Gym Membership, Workout Tracking & Performance Analytics System**

---

# ğŸŸ¦ **Project Theme**

You must build a smart fitness backend to manage:

* Members
* Trainers
* Workout Sessions
* Membership Plans
* Performance Analytics (using Streams)

The system should have:

* REST APIs
* Services using @Service
* Config using @Configuration + @Bean
* Environment-specific trainer allocation using @Profile
* JPA with inheritance hierarchy
* Streams everywhere (filter, group, sort, map, reduce)

---

# ğŸŸ© **OOP Modeling Requirements**

## â­ 1. **Trainer Hierarchy (Inheritance + Polymorphism)**

Create an inheritance structure:

```
Trainer (abstract)
   â”œâ”€â”€ YogaTrainer
   â”œâ”€â”€ CardioTrainer
   â””â”€â”€ StrengthTrainer
```

### Trainer Fields:

* id
* name
* experienceYears
* specialization (string)

### MUST include:

`abstract double calculateSessionCost();`
Each subclass applies its own formula.

Example:

* `YogaTrainer` â†’ base 500 + (experience * 20)
* `StrengthTrainer` â†’ base 800 + (experience * 50)
* Your choice

### Persistence:

Use **JPA Inheritance**

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "trainer_type")
```

---

# â­ 2. **Member Class (Composition)**

Fields:

* id
* name
* age
* membershipPlan (an enum: BASIC, PREMIUM, ULTRA)
* List<WorkoutSession> sessions

Members â†’ HAVE workout sessions.

---

# â­ 3. **Workout Session Entity**

Fields:

* sessionId
* date
* duration (minutes)
* caloriesBurned
* Trainer trainer (ManyToOne)
* Member member (ManyToOne)

---

# â­ 4. **Repository Layer**

Create JPA repositories for:

* TrainerRepository
* MemberRepository
* WorkoutSessionRepository

---

# â­ 5. **Service Layer Requirements**

(Service must be interface + @Service implementation)

### Required interface methods:

#### ğŸ¯ **A. CRUD**

```
Trainer registerTrainer(Trainer trainer);
Member registerMember(Member member);
WorkoutSession createWorkoutSession(int memberId, int trainerId, String date, int duration);
```

#### ğŸ¯ **B. Polymorphic Bill Calculation**

When creating a session:

```
double cost = trainer.calculateSessionCost();
```

#### ğŸ¯ **C. Stream-Based Analytics (IMPORTANT)**

You MUST implement these using:

* lambdas
* streams
* collectors
* grouping
* averaging
* max/min

---

# ğŸ”¥ **Mandatory Stream-Based Operations (add these in interface)**

### 1ï¸âƒ£ **Get top N members by total calories burned**

```java
List<Member> getTopMembersByCalories(int limit);
```

### 2ï¸âƒ£ **Get average calories burned per session for a member**

```java
double getAverageCaloriesForMember(int memberId);
```

### 3ï¸âƒ£ **Get total revenue generated by each trainer**

Return a **Map<Trainer, Double>**

```java
Map<Trainer, Double> getRevenuePerTrainer();
```

Use:

* `groupingBy()`
* `summingDouble()`

### 4ï¸âƒ£ **Get sessions filtered by date range**

```java
List<WorkoutSession> getSessionsBetween(String startDate, String endDate);
```

### 5ï¸âƒ£ **Get most active trainer by number of sessions**

```java
Trainer getMostActiveTrainer();
```

### 6ï¸âƒ£ **Group members by membership plan**

```java
Map<MembershipPlan, List<Member>> groupMembersByPlan();
```

### 7ï¸âƒ£ **Find trainer with highest average calories burned in their sessions**

```java
Trainer getBestPerformanceTrainer();
```

### 8ï¸âƒ£ **Find total calories burned grouped by trainer specialization**

```java
Map<String, Integer> getCaloriesGroupedBySpecialization();
```

### 9ï¸âƒ£ **Sort sessions by duration (descending)**

```java
List<WorkoutSession> sortSessionsByDuration();
```

### ğŸ”Ÿ **Find member progress summary (Calories Burned â†’ HashMap)**

Return:

```java
HashMap<String, Object> getMemberProgressSummary(int memberId);
```

Required fields in returned map:

```
{
  "totalSessions": 12,
  "totalCalories": 3220,
  "averageCalories": 268.3,
  "longestSession": 90,
  "shortestSession": 30
}
```

---

# ğŸŸ¦ **Controller Layer Requirements**

Create `@RestController` class with:

* @GetMapping("/members/{id}/averageCalories")
* @GetMapping("/trainers/mostActive")
* @PostMapping("/session/book")
* @GetMapping("/sessions/range")
* @GetMapping("/members/{id}/progress")
* @GetMapping("/trainers/revenue")
* @GetMapping("/members/top")

Use:

* @RequestParam
* @PathVariable

---

# ğŸŸ¨ **Configuration Requirements**

### Profiles

Two bean versions of "TrainerSelector":

```java
public interface TrainerSelector {
    Trainer assignTrainer();
}
```

#### Profile 1: `@Profile("dev")`

Always return a **YogaTrainer**

#### Profile 2: `@Profile("prod")`

Select trainer based on:

* availability
* lowest workload (use streams)

Register using:

```java
@Configuration
public class TrainerConfig {

    @Bean
    @Profile("dev")
    public TrainerSelector devSelector() { ... }

    @Bean
    @Profile("prod")
    public TrainerSelector prodSelector() { ... }
}
```

---

# ğŸŸ¥ **Dependency Injection Requirements**

Use all:

* @Autowired
* @Qualifier
* @Service
* @Configuration
* @Bean
* @Profile
* @RestController

Controllers must depend on services,
services must inject repositories.

---

# ğŸŸª **Sample Inputs (User Simulation)**

### Create a session:

```
POST /session/book
{
  "memberId": 10,
  "trainerId": 3,
  "date": "2025-02-05",
  "duration": 60
}
```

### Get top members:

```
GET /members/top?limit=3
```

### Get revenue by trainer:

```
GET /trainers/revenue
```

---

# ğŸ¯ **Your Learning Outcomes Today**

You will practice:

âœ” Inheritance
âœ” Polymorphism in bill calculation
âœ” Composition (Member â†’ Sessions)
âœ” Layered architecture
âœ” Dependency Injection
âœ” Profiles & Qualifier
âœ” JPA inheritance & relations
âœ” Controller mappings
âœ” Streams API deeply (filter, sort, group, map, average)
âœ” Designing complex interfaces
âœ” Working with Maps and HashMaps

---

# â­ Ready to start?

Just say:

ğŸ‘‰ **"Give me Level 1 tasks"**
or
ğŸ‘‰ **"Show me the class diagram so I can start coding"**
